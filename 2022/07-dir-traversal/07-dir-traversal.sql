drop table input;
create table input (
    id int generated by default as identity,
    cmd text
);

\copy input(cmd) from 'path/to/input.csv' csv header delimiter ',';

------------------------------------------------------------------------------
-- helper: path_agregate builds a path from a sequence of `cd` instructions --
------------------------------------------------------------------------------

drop aggregate path_aggregate(TEXT[]);
drop function descend_dir(current TEXT[], target TEXT[]);

/*
 Appends target to current path, or backtrack one level if target is '..'.
 */
create or replace function descend_dir(current text[], target text[])
    returns text[]
    immutable
    language sql
as $$
select case
        when target = '{..}' then current[:cardinality(current) - 1]
        else current || target
    end
$$;

create or replace aggregate path_aggregate (text[]) (
    sfunc = descend_dir,
    stype = text[]
);

------------------------------------------------------------------------------

create temp table input_decorated as
with a as (
    select *,
        count(*)
            filter (where cmd ~ '\$ cd')
            over (order by id)
            as working_dir_number
    from input
),
b as (
    select
        working_dir_number,
        max((regexp_match(cmd, '^\$ cd (.*)'))[1]) as current_working_directory,
        array_agg(
            coalesce(nullif(
                (regexp_match(cmd, '\d*'))[1],
                ''
            )::int, 0))
            filter (where cmd !~ '\$ .*') as filesizes
    from a
    group by 1
    order by 1
)
select
    working_dir_number,
    path_aggregate(array[current_working_directory])
        over (order by working_dir_number)
        as path,
    filesizes
from b
;

-- build tree ğŸ„ from paths
drop table if exists dir_tree;
create table dir_tree as
select distinct
    path[:cardinality(path) - 1] as parent,
    path[:cardinality(path)] as current,
    cardinality(path) as depth,
    path,
    filesizes
from input_decorated
where filesizes is not null
order by 3, 1, 2
;

-- agregate filesizes by branch
-- @fixme: wrong way recursion (top-down instead of bottom-up)  ğŸ™
with recursive q as (
    select
        depth,
        parent,
        current,
        filesizes
    from dir_tree
    where current = '{/}'
    union all
    select
        dir_tree.depth,
        dir_tree.parent,
        dir_tree.current,
        dir_tree.filesizes || q.filesizes as filesizes
    from dir_tree
    join q on dir_tree.parent = q.current
)
select
    *
from q
order by depth
;

-- using the ltree extension (definitely not standard sql, I know ğŸ˜…)
-- https://www.postgresql.org/docs/current/ltree.html
-- create extension ltree;
with ltrees as (
    select
        *,
        translate(
            replace(current::text, ',', '.'),
        '/{}', 'x')::ltree as ltree,
        (select sum(n) from unnest(filesizes) _(n))
    from dir_tree
)
select
    parents.depth,
    parents.ltree,
    sum(children.sum)
from ltrees children
join ltrees parents on children.ltree <@ parents.ltree
group by parents.depth, parents.ltree
having sum(children.sum) < 100000
order by parents.depth