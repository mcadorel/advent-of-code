drop table if exists moves;
create table moves (
    n int generated by default as identity,
    direction char,
    steps int
);

copy moves(direction,  steps) from 'path/to/input.csv' csv header delimiter ' ';

-- expand to single-step moves
drop table if exists steps;
create table steps as
select
    n::int as n,
    row_number() over () as step,
    step::char as direction
from moves, regexp_split_to_table(
    repeat(direction, steps),
    ''
) _(step)
order by 1;

-- retrace all steps
create table steps_with_positions as
with recursive q as (
    select
        0::bigint as step,
        'S'::char as direction,
        (0, 0, 0, 0)::rope_position as rope_position
    union all
    select
        steps.step,
        steps.direction,
        case steps.direction
            when 'R' then r(q.rope_position)
            when 'L' then l(q.rope_position)
            when 'D' then d(q.rope_position)
            when 'U' then u(q.rope_position)
        end as rope_position
    from q, steps
    where steps.step = q.step + 1
    and steps.step <= 11316
)
select *
from q
;

with absolute_positions as (
    -- not needed, just for fun & debug
    select
        step,
        direction,
        (rope_position).hy,
        (rope_position).hx,
        (rope_position).hy + (rope_position).ty as ty,
        (rope_position).hx + (rope_position).tx as tx
    from steps_with_positions
)
select count(distinct (ty, tx))
from absolute_positions
;